# backend/app/api/endpoints/report.py
# -*- coding: utf-8 -*-
from typing import Any, Dict
import io

from fastapi import APIRouter, Depends, HTTPException, status, Path
from fastapi.responses import StreamingResponse
from sqlalchemy.orm import Session

from app.db.session import get_db
from app.core import security
from app.models.user import User as UserModel
from app.models.project import Project as ProjectModel
from app.services.report import get_official_report_from_api

router = APIRouter()

def _get_project_data_for_report(db: Session, project_id: int, current_user: UserModel) -> Dict:
    """
    Retrieves and structures project data for the reporting service.
    """
    project = db.query(ProjectModel).filter(ProjectModel.id == project_id, ProjectModel.owner_id == current_user.id).first()
    if not project:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Project not found or not authorized for the current user.")

    # Create a structured dictionary that matches the frontend's data model
    # and the expectations of the report service. Using dummy data for now.
    input_data = project.input_data or {}
    building_data = input_data.get("building", {})
    systems_data = input_data.get("systems", {})
    envelope_data = input_data.get("envelope", {})

    # Consolidate all data into a single dictionary to pass to the service
    # This structure should be refined to match the actual data model from the frontend/database
    report_input_data = {
        "building": {
            "name": project.name,
            "climate_zone": building_data.get("climate_zone", 6),
            "building_type": building_data.get("building_type", "office"),
            "total_floor_area": building_data.get("total_floor_area", 500.0),
            "total_floor": envelope_data.get("num_stories", 2),
            "building_height": envelope_data.get("building_height", 8.0),
            "uvalue_exterior_wall": envelope_data.get("u_value_wall", 0.5),
            "uvalue_roof": envelope_data.get("u_value_roof", 0.4),
        },
        "systems": {
            "cooling": systems_data.get("cooling", {}),
            "heating": systems_data.get("heating", {}),
            "ventilation": systems_data.get("ventilation", {}),
            "hot_water": systems_data.get("hot_water", {}),
            "lighting": systems_data.get("lighting", {}),
            "elevator": systems_data.get("elevator", {}),
        }
    }

    return report_input_data

@router.get(
    "/{project_id}/report/excel",
    response_class=StreamingResponse,
    summary="Download Official PDF Report",
    description="Generates and downloads an official PDF report by calling the external API.",
)
async def download_official_report_endpoint(
    project_id: int = Path(..., title="Project ID"),
    db: Session = Depends(get_db),
    current_user: UserModel = Depends(security.get_current_active_user)
) -> StreamingResponse:
    """
    Downloads the official PDF report generated by the external API.
    """
    project_data = _get_project_data_for_report(db, project_id, current_user)

    try:
        pdf_content = get_official_report_from_api(project_data)
        
        file_name = f"{project_data.get('building',{}).get('name', 'project')}_official_report.pdf".replace(" ", "_")
        
        return StreamingResponse(
            io.BytesIO(pdf_content),
            media_type="application/pdf",
            headers={"Content-Disposition": f"attachment; filename={file_name}"}
        )

    except Exception as e:
        print(f"Error generating official report: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to generate the official report. Reason: {str(e)}"
        )