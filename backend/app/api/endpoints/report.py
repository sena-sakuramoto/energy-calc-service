# backend/app/api/endpoints/report.py
# -*- coding: utf-8 -*-
from typing import Any, Dict
import io

from fastapi import APIRouter, Depends, HTTPException, status, Path
from fastapi.responses import StreamingResponse
from sqlalchemy.orm import Session

from app.db.session import get_db
from app.core import security
from app.models.user import User as UserModel
from app.models.project import Project as ProjectModel
from app.services.report import get_official_report_from_api

router = APIRouter()

def _get_project_data_for_report(db: Session, project_id: int, current_user: UserModel) -> Dict:
    """
    Retrieves and structures complete project data for the reporting service.
    """
    project = db.query(ProjectModel).filter(ProjectModel.id == project_id, ProjectModel.owner_id == current_user.id).first()
    if not project:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Project not found or not authorized for the current user.")

    # The frontend stores all input data in a single JSON field `input_data`
    input_data = project.input_data or {}
    
    # The service expects a specific nested structure.
    # We extract the data from the flat `input_data` and build the nested structure.
    # This acts as an anti-corruption layer.
    report_input_data = {
        "building": {
            "name": project.name,
            "climate_zone": input_data.get("climate_zone"),
            "building_type": input_data.get("building_type"),
            "total_floor_area": input_data.get("floor_area"),
            # Add other building fields from input_data as needed
        },
        "systems": {
            "cooling": input_data.get("design_energy", {}).get("cooling"),
            "heating": input_data.get("design_energy", {}).get("heating"),
            "ventilation": input_data.get("design_energy", {}).get("ventilation"),
            "hot_water": input_data.get("design_energy", {}).get("hot_water"),
            "lighting": input_data.get("design_energy", {}).get("lighting"),
            "elevator": input_data.get("design_energy", {}).get("elevator"),
        }
    }

    # It's better to extract the detailed system properties from input_data
    # For example:
    # report_input_data["systems"]["cooling"] = {
    #     "ac_cop_cooling": input_data.get("cooling_cop"),
    #     # ... etc
    # }
    # For now, we pass the raw energy values.

    return report_input_data

@router.get(
    "/{project_id}/report/excel",
    response_class=StreamingResponse,
    summary="Download Official PDF Report",
    description="Generates and downloads an official PDF report by calling the external API.",
)
async def download_official_report_endpoint(
    project_id: int = Path(..., title="Project ID"),
    db: Session = Depends(get_db),
    current_user: UserModel = Depends(security.get_current_active_user)
) -> StreamingResponse:
    """
    Downloads the official PDF report generated by the external API.
    """
    project_data = _get_project_data_for_report(db, project_id, current_user)

    try:
        pdf_content = get_official_report_from_api(project_data)
        
        file_name = f"{project_data.get('building',{}).get('name', 'project')}_official_report.pdf".replace(" ", "_")
        
        return StreamingResponse(
            io.BytesIO(pdf_content),
            media_type="application/pdf",
            headers={"Content-Disposition": f"attachment; filename={file_name}"}
        )

    except Exception as e:
        print(f"Error generating official report: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to generate the official report. Reason: {str(e)}"
        )
