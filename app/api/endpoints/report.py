# backend/app/api/endpoints/report.py
# -*- coding: utf-8 -*-
from typing import Any, Dict
import io

from fastapi import APIRouter, Depends, HTTPException, status, Path
from fastapi.responses import StreamingResponse
from sqlalchemy.orm import Session

from app.db.session import get_db
from app.core import security
from app.models.user import User as UserModel
from app.models.project import Project as ProjectModel
from app.services.report import get_official_report_from_api, build_minimal_official_building

router = APIRouter()

def _get_project_data_for_report(db: Session, project_id: int, current_user: UserModel) -> Dict:
    """
    Retrieves and structures complete project data for the reporting service.
    """
    project = db.query(ProjectModel).filter(ProjectModel.id == project_id, ProjectModel.owner_id == current_user.id).first()
    if not project:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Project not found or not authorized for the current user.")

    # The frontend stores all input data in a single JSON field `input_data`.
    # This endpoint supports legacy project records and only builds minimum 様式A.
    input_data = project.input_data or {}
    nested_building = input_data.get("building", {}) if isinstance(input_data.get("building"), dict) else {}
    try:
        building = build_minimal_official_building(
            building_area_m2=input_data.get("floor_area") or nested_building.get("total_floor_area"),
            use=input_data.get("building_type") or nested_building.get("building_type"),
            zone=input_data.get("climate_zone") or nested_building.get("climate_zone"),
            building_name=project.name,
        )
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"公式帳票生成に必要な入力が不足/不正です: {str(e)}",
        )
    return {"building": building}

@router.get(
    "/{project_id}/report/excel",
    response_class=StreamingResponse,
    summary="Download Official PDF Report",
    description="Generates and downloads an official PDF report by calling the external API.",
)
async def download_official_report_endpoint(
    project_id: int = Path(..., title="Project ID"),
    db: Session = Depends(get_db),
    current_user: UserModel = Depends(security.get_current_active_user)
) -> StreamingResponse:
    """
    Downloads the official PDF report generated by the external API.
    """
    project_data = _get_project_data_for_report(db, project_id, current_user)

    try:
        pdf_content = get_official_report_from_api(project_data)
        
        file_name = (
            f"{project_data.get('building', {}).get('building_name', 'project')}_official_report.pdf"
            .replace(" ", "_")
        )
        
        return StreamingResponse(
            io.BytesIO(pdf_content),
            media_type="application/pdf",
            headers={"Content-Disposition": f"attachment; filename={file_name}"}
        )

    except Exception as e:
        print(f"Error generating official report: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to generate the official report. Reason: {str(e)}"
        )
